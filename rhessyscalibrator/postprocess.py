"""@package rhessyscalibrator.postprocess

@brief Tool for analyzing model run results generated by rhessys_calibrator.py and 
stored in a database format managed by rhessyscalibrator.model_runner_db.py.  Currently
calculates NSE and NSE-log for each completed run in the calibration database.
Results can be viewed in the companion rhessys_calibrator_results.py

This software is provided free of charge under the New BSD License. Please see
the following license information:

Copyright (c) 2013, University of North Carolina at Chapel Hill
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the University of North Carolina at Chapel Hill nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


@author Brian Miles <brian_miles@unc.edu>
"""
import sys
import os
import errno
from optparse import OptionParser
import argparse
import logging
# import string
# from datetime import datetime
# from datetime import timedelta
# from collections import OrderedDict

import math
import numpy
import pandas as pd
import matplotlib
matplotlib.use('Agg') # Allow for running on machines without X servers
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

from rhessyscalibrator.calibrator import RHESSysCalibrator
from rhessyscalibrator.model_runner_db2 import *

OBS_HEADER_STREAMFLOW = 'streamflow_mm'
OBS_HEADER_PRECIP = 'precip_mm'

class RHESSysCalibratorPostprocess(object):
    """ Main driver class for rhessys_calibrator_postprocess tool
    """
    PARAM_S1_IDX = 0
    PARAM_S1_NAME = 'm - drainage'
    PARAM_S2_IDX = 1
    PARAM_S2_NAME = 'Ksat0 - drainage'
    PARAM_S3_IDX = 2
    PARAM_S3_NAME = 'soil depth'
    PARAM_SV1_IDX = 3
    PARAM_SV1_NAME = 'vertical m'
    PARAM_SV2_IDX = 4
    PARAM_SV2_NAME = 'vertical Ksat0'
    PARAM_GW1_IDX = 5
    PARAM_GW1_NAME = 'sat. to GW'
    PARAM_GW2_IDX = 6
    PARAM_GW2_NAME = 'GW loss'
    PARAM_VGSEN1_IDX = 7
    PARAM_VGSEN1_NAME = 'proj. SLA'
    PARAM_VGSEN2_IDX = 8
    PARAM_VGSEN2_NAME = 'shaded SLA'
    PARAM_VGSEN3_IDX = 9
    PARAM_VGSEN3_NAME = 'vgsen3'
    PARAM_SVALT1_IDX = 10
    PARAM_SVALT1_NAME = 'psi air entry'
    PARAM_SVALT2_IDX = 11
    PARAM_SVALT2_NAME = 'pore size index'
    PARAM_INDICES = (PARAM_S1_IDX, PARAM_S2_IDX,
                     PARAM_S3_IDX, PARAM_SV1_IDX,
                     PARAM_SV2_IDX, PARAM_GW1_IDX,
                     PARAM_GW2_IDX, PARAM_VGSEN1_IDX,
                     PARAM_VGSEN2_IDX, PARAM_VGSEN3_IDX,
                     PARAM_SVALT1_IDX, PARAM_SVALT2_IDX)
    NUM_PARAM_INDICES = len(PARAM_INDICES)
    
    PARAM_NAMES = { 
                   PARAM_S1_IDX: PARAM_S1_NAME,
                   PARAM_S2_IDX: PARAM_S2_NAME,
                   PARAM_S3_IDX: PARAM_S3_NAME,
                   PARAM_SV1_IDX: PARAM_SV1_NAME,
                   PARAM_SV2_IDX: PARAM_SV2_NAME,
                   PARAM_GW1_IDX: PARAM_GW1_NAME,
                   PARAM_GW2_IDX: PARAM_GW2_NAME,
                   PARAM_VGSEN1_IDX: PARAM_VGSEN1_NAME,
                   PARAM_VGSEN2_IDX: PARAM_VGSEN2_NAME,
                   PARAM_VGSEN3_IDX: PARAM_VGSEN3_NAME,
                   PARAM_SVALT1_IDX: PARAM_SVALT1_NAME,
                   PARAM_SVALT2_IDX: PARAM_SVALT2_NAME
                   }
    
    def __init__(self):
        self.params = set()
        self.plotData = {}
        self.plotDataIdx = -1
        self.numRuns = 0
        self.numParams = -1

    def _initLogger(self, level):
        """ Setup logger.  Log to the console for now """
        self.logger = logging.getLogger("cluster_calibrator")
        self.logger.setLevel(level)
        # console handler and set it to level
        consoleHandler = logging.StreamHandler()
        consoleHandler.setLevel(level)
        # create formatter
        formatter = \
            logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        # add formatter to console handler
        consoleHandler.setFormatter(formatter)
        # add consoleHandler to logger
        self.logger.addHandler(consoleHandler)

    @classmethod
    def logTransform(cls, list1, list2):
        """ Log10 transform two lists, filtering values <= 0 in each.  Lists
            must be of same cardinality.  List cardinality and list
            item parity will be maintained.  Thus, if list1[i] == 0,
            both list1[i] and list2[i] will be skipped over.  Original
            lists will be left unchanged.

            Arguments:
            list1 -- list   The first list
            list2 -- list   The second list

            Returns a tuple containing the filtered lists.
        """
        assert(len(list1) == len(list2))

        # Maybe find a way to more efficiently allocate these
        ret_list1 = list()
        ret_list2 = list()

        idx = 0
        for item in list1:
            if list1[idx] > 0 and list2[idx] > 0:
                ret_list1.append(math.log10(list1[idx]))
                ret_list2.append(math.log10(list2[idx]))
            idx += 1

        return (ret_list1, ret_list2)

    @classmethod
    def calculateNSE(cls, obs, model, obs_mean=None):
        """ Calculate Nash-Sutcliffe efficiency (NSE) (Moriasi et al. 2007).

            Arguments:
            obs -- list<float>   Observed data
            model -- list<float> Modeled data
            obs_avg -- float     Mean of obs data (if None will be calculated)

            Returns a float representing the NSE
        """
        if None == obs_mean:
            obs_mean = sum(obs) / len(obs)

        numerator = 0
        denominator = 0

        idx = 0
        for datum in model:
            numerator += (obs[idx] - model[idx]) ** 2
            denominator += (obs[idx] - obs_mean) ** 2
            idx += 1

        assert(denominator != 0)
        return 1 - (numerator / denominator)

    
    def _storePerformanceDataForRun(self, run, data, performance):
        self.numParams = -1
        if run.param_s1:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_S1_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_S1_IDX, 0] = run.param_s1
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_S1_IDX, 1] = performance
        if run.param_s2:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_S2_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_S2_IDX, 0] = run.param_s2
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_S2_IDX, 1] = performance
        if run.param_s3:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_S3_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_S3_IDX, 0] = run.param_s3
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_S3_IDX, 1] = performance
        if run.param_sv1:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_SV1_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_SV1_IDX, 0] = run.param_sv1
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_SV1_IDX, 1] = performance
        if run.param_sv2:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_SV2_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_SV2_IDX, 0] = run.param_sv2
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_SV2_IDX, 1] = performance
        if run.param_gw1:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_GW1_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_GW1_IDX, 0] = run.param_gw1
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_GW1_IDX, 1] = performance
        if run.param_gw2:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_GW2_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_GW2_IDX, 0] = run.param_gw2
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_GW2_IDX, 1] = performance
        if run.param_vgsen1:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_VGSEN1_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_VGSEN1_IDX, 0] = run.param_vgsen1
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_VGSEN1_IDX, 1] = performance
        if run.param_vgsen2:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_VGSEN2_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_VGSEN2_IDX, 0] = run.param_vgsen2
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_VGSEN2_IDX, 1] = performance
        if run.param_vgsen3:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_VGSEN3_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_VGSEN3_IDX, 0] = run.param_vgsen3
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_VGSEN3_IDX, 1] = performance
        if run.param_svalt1:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_SVALT1_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_SVALT1_IDX, 0] = run.param_svalt1
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_SVALT1_IDX, 1] = performance
        if run.param_svalt2:
            self.numParams += 1
            self.params.add(RHESSysCalibratorPostprocess.PARAM_SVALT2_IDX)
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_SVALT2_IDX, 0] = run.param_svalt2
            data[self.plotDataIdx, RHESSysCalibratorPostprocess.PARAM_SVALT2_IDX, 1] = performance
    
    
    def recordPlotDataForRun(self, run, nse, nse_log, pbias=None, rsr=None, 
                             user1=None, user2=None, user3=None):
        """
            @param run rhessyscalibrator.model_runner_db.ModelRun
        """
        self.plotDataIdx += 1
        
        try:
            data = self.plotData['nse']
        except KeyError:
            data = numpy.zeros( [self.numRuns, RHESSysCalibratorPostprocess.NUM_PARAM_INDICES, 2] )
            self.plotData['nse'] = data
        self._storePerformanceDataForRun(run, data, nse)
        
        try:
            data = self.plotData['nse_log']
        except KeyError:
            data = numpy.zeros( [self.numRuns, RHESSysCalibratorPostprocess.NUM_PARAM_INDICES, 2] )
            self.plotData['nse_log'] = data
        self._storePerformanceDataForRun(run, data, nse_log)
        
        if pbias:
            try:
                data = self.plotData['pbias']
            except KeyError:
                data = numpy.zeros( [self.numRuns, RHESSysCalibratorPostprocess.NUM_PARAM_INDICES, 2] )
                self.plotData['pbias'] = data
            self._storePerformanceDataForRun(run, data, pbias)
            
        if rsr:
            try:
                data = self.plotData['rsr']
            except KeyError:
                data = numpy.zeros( [self.numRuns, RHESSysCalibratorPostprocess.NUM_PARAM_INDICES, 2] )
                self.plotData['rsr'] = data
            self._storePerformanceDataForRun(run, data, rsr)
            
        if user1:
            try:
                data = self.plotData['user1']
            except KeyError:
                data = numpy.zeros( [self.numRuns, RHESSysCalibratorPostprocess.NUM_PARAM_INDICES, 2] )
                self.plotData['user1'] = data
            self._storePerformanceDataForRun(run, data, user1)
            
        if user2:
            try:
                data = self.plotData['user2']
            except KeyError:
                data = numpy.zeros( [self.numRuns, RHESSysCalibratorPostprocess.NUM_PARAM_INDICES, 2] )
                self.plotData['user2'] = data
            self._storePerformanceDataForRun(run, data, user2)
            
        if user3:
            try:
                data = self.plotData['user3']
            except KeyError:
                data = numpy.zeros( [self.numRuns, RHESSysCalibratorPostprocess.NUM_PARAM_INDICES, 2] )
                self.plotData['user3'] = data
            self._storePerformanceDataForRun(run, data, user3)
    
   
    def pair(self, data, figsize=None, dpi=80, labels=None, hist=False):
        """ Generate something similar to R `pair` 
            Adapted from http://stackoverflow.com/a/2690063/2026701
        """
    
        nVariables = data.shape[1]
        if labels is None:
            labels = [RHESSysCalibratorPostprocess.PARAM_NAMES[i] for i in range(nVariables)]
        fig = plt.figure(figsize=figsize, dpi=dpi)
        for i in range(nVariables):
            for j in range(nVariables):
                nSub = i * nVariables + j + 1
                ax = fig.add_subplot(nVariables, nVariables, nSub)
                ax.tick_params(labelsize='xx-small')
                ax.locator_params(axis='x', nbins=4)
                if i == 0:
                    ax.set_title(labels[j], fontsize='x-small')
                if j == 0:
                    ax.set_ylabel(labels[i], fontsize='x-small')
                if i == j:
                    if hist:
                        ax.hist(data[:,i])
                        ax.set_xlim(0, 1)
                        ax.set_title(labels[i], fontsize='x-small')
                    else:
                        ax.set_xticks([])
                        ax.set_yticks([])
                else:
                    #ax.set_xlim(-1, 1)
                    #ax.set_ylim(-1, 1)
                    #ax.plot(data[:,i], data[:,j])
                    ax.scatter(data[:,i], data[:,j], facecolors='none', edgecolors='blue', linewidth='0.5')
    
        plt.tight_layout(h_pad=0.1, w_pad=0.1)
    
        return fig
    
    
    def pair3d(self, data, z, figsize=None, dpi=80, 
               labels=None, zlabel=None, hist=False, surface=False,
               title='Figure title'):
        """ Generate something similar to R `pair` 
            Adapted from http://stackoverflow.com/a/2690063/2026701
        """
    
        nVariables = data.shape[0]
        if labels is None:
            labels = [RHESSysCalibratorPostprocess.PARAM_NAMES[i] for i in range(nVariables)]
        fig = plt.figure(figsize=figsize, dpi=dpi)
        plt.suptitle(title, y=0.99)
        for i in range(nVariables):
            for j in range(nVariables):
                nSub = i * nVariables + j + 1
                ax = fig.add_subplot(nVariables, nVariables, nSub, projection='3d')
                ax.tick_params(labelsize='xx-small')
                ax.locator_params(axis='x', nbins=4)
                ax.locator_params(axis='y', nbins=4)
                ax.locator_params(axis='z', nbins=4)
                ax.set_xlabel('\n\n' + labels[i], fontsize='x-small')
                ax.set_ylabel('\n\n' + labels[j], fontsize='x-small')
                if j == nVariables - 1:
                    ax.set_zlabel('\n\n' + zlabel, fontsize='x-small')
                    #ax.text(0.5, 0.5, labels[i], rotation='vertical')
                if i == j:
                    if hist:
                        ax.hist(data[:,i])
                        ax.set_xlim(0, 1)
                        ax.set_title(labels[i], fontsize='x-small')
                    else:
                        ax.set_xticks([])
                        ax.set_yticks([])
                else:
                    if surface:
                        (X, Y) = numpy.meshgrid(data[i,:], data[j,:])
                        (Z, Z) = numpy.meshgrid(z[i,:], z[j,:])
                        ax.plot_surface(X, Y, Z)
                    #ax.plot_surface()
                    else:
                        X = data[i,:]
                        Y = data[j,:]
                        Z = z[i,:]
                        ax.scatter(X, Y, Z)
    
        plt.tight_layout(h_pad=1.3, w_pad=1.0)
    
        return fig
    
    
    def saveCovariancePlot(self, outDir, filename, format='PDF', sizeX=1, sizeY=1, dpi=80):
        """ Save covariance plots showing parameter relationships to outDir 
            Potential reference: http://glowingpython.blogspot.com/2012/10/visualizing-correlation-matrices.html
        """
        assert( format in ['PDF', 'PNG'] )
        if format == 'PDF':
            plotFilename = "%s.pdf" % (filename,)
        elif format == 'PNG':
            plotFilename = "%s.png" % (filename,)

        if 'nse' in self.plotData.keys():
            
            plotFilename = "nse_" + plotFilename
            plotFilepath = os.path.join(outDir, plotFilename)
                
            data = self.plotData['nse']
            # Data are stored as: data[numRuns,numParameters,2] 
            #   WHERE data[numRuns,numParameters, 0] = value of parameters
            #   AND data[numRuns,numParameters, 1] = value of performance criterion
            #
            # For numpy.cov input matrix m has:
            #   variables in rows and observations in columns
            # So the form must be:
            # m = numpy.zeros( (RHESSysCalibratorPostprocess.NUM_PARAM_INDICES, self.numRuns) )
            #     
            param = numpy.transpose(data[:, 0:self.numParams+1, 0])
            z = numpy.transpose(data[:, 0:self.numParams+1, 1])
            fig = self.pair3d(param, z, figsize=(sizeX, sizeY), dpi=dpi, 
                              zlabel='N-S efficiency', title='N-S efficiency for daily streamflow')
            fig.savefig(plotFilepath, format=format, bbox_inches='tight', pad_inches=0.25)

        if 'nse_log' in self.plotData.keys():
            
            plotFilename = "nse_log_" + plotFilename
            plotFilepath = os.path.join(outDir, plotFilename)
                
            data = self.plotData['nse_log']
            param = numpy.transpose(data[:, 0:self.numParams+1, 0])
            z = numpy.transpose(data[:, 0:self.numParams+1, 1])
            fig = self.pair3d(param, z, figsize=(sizeX, sizeY), dpi=dpi, 
                              zlabel='N-S efficiency', title='N-S efficiency for log daily streamflow')
            fig.savefig(plotFilepath, format=format, bbox_inches='tight', pad_inches=0.25)
                
    
    def saveDottyPlot(self, outDir, filename, format='PDF', sizeX=1, sizeY=1, dpi=80):
        """ Save dotty plots showing parameter sensitivity to outDir 
        """
        assert( format in ['PDF', 'PNG'] )
        if format == 'PDF':
            plotFilename = "%s.pdf" % (filename,)
        elif format == 'PNG':
            plotFilename = "%s.png" % (filename,)
        plotFilepath = os.path.join(outDir, plotFilename)
        
        fontsize = 'x-small'
        
        numRows = len( self.plotData.keys() )
        numCols = len( self.params )
        fig, ax = plt.subplots(nrows=numRows, ncols=numCols, sharey='row', squeeze=False, 
                               figsize=(sizeX, sizeY), dpi=dpi)
        fig.subplots_adjust(wspace=0.3)
        
        currSubplot = -1
        
        if RHESSysCalibratorPostprocess.PARAM_S1_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_S1_NAME, fontsize=fontsize)
            a.set_ylabel('N-S efficiency for daily streamflow', fontsize='xx-small')
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_S1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_S1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 20)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_S1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_S1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 20)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
                a.set_ylabel('N-S efficiency for log daily streamflow', fontsize='xx-small')
                
        if RHESSysCalibratorPostprocess.PARAM_S2_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_S2_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_S2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_S2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 150)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_S2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_S2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 150)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
                
        if RHESSysCalibratorPostprocess.PARAM_S3_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_S3_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_S3_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_S3_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 10)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_S3_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_S3_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 10)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
                
        if RHESSysCalibratorPostprocess.PARAM_SV1_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_SV1_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_SV1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_SV1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 10)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_SV1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_SV1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 10)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
                
        if RHESSysCalibratorPostprocess.PARAM_SV2_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_SV2_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_SV2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_SV2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 50)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_SV2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_SV2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 50)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
                
        if RHESSysCalibratorPostprocess.PARAM_GW1_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_GW1_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_GW1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_GW1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 1)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_GW1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_GW1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 1)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
        
        if RHESSysCalibratorPostprocess.PARAM_GW2_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_GW2_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_GW2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_GW2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 1)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_GW2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_GW2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 1)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
                
        if RHESSysCalibratorPostprocess.PARAM_VGSEN1_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_VGSEN1_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
        
        if RHESSysCalibratorPostprocess.PARAM_VGSEN2_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_VGSEN2_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
        
        if RHESSysCalibratorPostprocess.PARAM_VGSEN3_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_VGSEN3_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN3_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN3_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN3_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_VGSEN3_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
        
        if RHESSysCalibratorPostprocess.PARAM_SVALT1_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_SVALT1_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_SVALT1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_SVALT1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_SVALT1_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_SVALT1_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
                
        if RHESSysCalibratorPostprocess.PARAM_SVALT2_IDX in self.params:
            currSubplot += 1
            a = ax[1, currSubplot]
            a.set_xlabel(RHESSysCalibratorPostprocess.PARAM_SVALT2_NAME, fontsize=fontsize)
            if 'nse' in self.plotData.keys():
                data = self.plotData['nse']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_SVALT2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_SVALT2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
            if 'nse_log' in self.plotData.keys():
                a = ax[0, currSubplot]
                data = self.plotData['nse_log']
                x = data[:, RHESSysCalibratorPostprocess.PARAM_SVALT2_IDX, 0]
                y = data[:, RHESSysCalibratorPostprocess.PARAM_SVALT2_IDX, 1]
                a.locator_params(axis='x', nbins=4)
                a.tick_params(labelsize=fontsize)
                a.margins(1)
                a.set_xlim(0, 5)
                a.set_ylim(0, 1)
                a.scatter(x, y, facecolors='none', edgecolors='blue', linewidth='0.5')
        
        fig.savefig(plotFilepath, format=format)
        

    def main(self, args):

        # Set up command line options
        parser = OptionParser(usage="""%prog --basedir=BASEDIR --file=OBS_FILE --session=SESSION_ID [optional arguments ...]

Run "%prog --help" for detailed description of all options
""")
        parser.add_option("-b", "--basedir", action="store", type="string", 
                          dest="basedir",
                          help="[REQUIRED] base directory for the calibration session")
        
        parser.add_option("-o", "--outdir", action="store", type="string",
                          dest="outdir",
                          help="[OPTIONAL] output directory in which to place dotty plot figures.  If not specified, basedir will be used.")

        parser.add_option("-f", "--file", action="store", type="string",
                          dest="observed_file",
                          help="[REQUIRED] the name of the observed file to use for calculating model fitness statistics.  Filename will be interpreted as being relative to $BASEDIR/obs")

        parser.add_option("-s", "--session", action="store", type="int",
                          dest="session_id",
                          help="[REQUIRED] the ID of the session for which model fitness statistics should be calculated")
        
        parser.add_option("--add_streamflow_and_gw", action="store_true",
                          dest="add_streamflow_and_gw",
                          help="[OPTIONAL] Add streamflow and gw.Qout columns instead of using streamflow alone")

        parser.add_option("-d", "--startdate", type="int", nargs=4,
                          dest="startdate", 
                          help="[OPTIONAL] Date from which to start fitness calculations, of format YYYY M D H. " + \
                               "Note: Hour must be specified for backward compatibility and will be ignored, hour will be set to 0:00.")

        parser.add_option("--enddate", type=int, nargs=4,
                          dest="enddate",
                          help="[OPTIONAL] Date on which to end fitness calculationss, of format YYYY M D H. " + \
                               "Note: Hour must be specified for backward compatibility and will be ignored, hour will be set to 0:00.")

        parser.add_option("-p", "--period",
                          dest="period", choices=['daily', 'weekly', 'monthly'], default='daily',
                          help="[OPTIONAL] Period over which fitness parameters will be calculated.")

        parser.add_option("-l", "--loglevel", action="store", type="string",
                          dest="loglevel", default="OFF",
                          help="[OPTIONAL] set logging level, one of: OFF [default], DEBUG, CRITICAL (case sensitive)")
        
        parser.add_option("--figureX", action="store", type="int",
                          dest="figureX", default=4,
                          help="[OPTIONAL] width of dotty plot figure, in inches")
        
        parser.add_option("--figureY", action="store", type="int",
                          dest="figureY", default=3,
                          help="[OPTIONAL] width of dotty plot figure, in inches")
        
        parser.add_option("--figureDPI", action="store", type="int",
                          dest="figureDPI", default=80,
                          help="[OPTIONAL] DPI of dotty plot figure")
        
        parser.add_option("--covplot", action="store_true", default=False,
                          help="[OPTIONAL] Write experimental co-variance plot.")
        
        (options, args) = parser.parse_args()

        # Enforce initial command line options rules
        if "DEBUG" == options.loglevel:
            self._initLogger(logging.DEBUG)
        elif "CRITICAL" == options.loglevel:
            self._initLogger(logging.CRITICAL)
        else:
            self._initLogger(logging.NOTSET)
            
        if not options.basedir:
            parser.error("Please specify the basedir for the calibration session")
        if not os.path.isdir(options.basedir) or not os.access(options.basedir, os.W_OK):
            sys.exit("Unable to write to basedir %s" % (options.basedir,) )
        basedir = os.path.abspath(options.basedir)
        
        if not options.outdir:
            options.outdir = basedir
            
        if not options.session_id:
            parser.error("Please specify the ID of session for which you'd like t calculate model fitness statistics")

        if not options.observed_file:
            parser.error("Please specify the name of the observed file to use for calculating model fitness statistics")

        if not os.path.isdir(options.outdir) and os.access(options.outdir, os.W_OK):
            parser.error("Figure output directory %s must be a writable directory" % (options.outdir,) )
        outdirPath = os.path.abspath(options.outdir)

        dbPath = RHESSysCalibrator.getDBPath(basedir)
        if not os.access(dbPath, os.R_OK):
            raise IOError(errno.EACCES, "The database at %s is not readable" %
                          dbPath)
        self.logger.debug("DB path: %s" % dbPath)

        obsPath = RHESSysCalibrator.getObsPath(basedir)
        obsFilePath = os.path.join(obsPath, options.observed_file)
        if not os.access(obsFilePath, os.R_OK):
            raise IOError(errno.EACCES, "The observed data file %s is  not readable" % obsFilePath)
        self.logger.debug("Obs path: %s" % obsFilePath)

        outputPath = RHESSysCalibrator.getOutputPath(basedir)
        if not os.access(outputPath, os.R_OK):
            raise IOError(errno.EACCES, "The output directory %s is  not readable" % outputPath)
        self.logger.debug("Output path: %s" % outputPath)

        rhessysPath = RHESSysCalibrator.getRhessysPath(basedir)

        # Read observed data from file
        obs_all = pd.read_csv(obsFilePath, index_col=0, parse_dates=True)

        startDate = None
        endDate = None
        if options.startdate:
            # Set start date based on command line
            startDate = datetime(options.startdate[0],
                                 options.startdate[1],
                                 options.startdate[2],
                                 0)
        else:
            # Set start data based on observed data
            startDate = obs_all.index[0].to_datetime()
            
        if options.enddate:
            # Set end date based on command line
            endDate = datetime(options.enddate[0],
                               options.enddate[1],
                               options.enddate[2],
                               0)
            if not endDate > startDate:
                sys.exit("End date %s is not greater than start date %s" % \
                         (str(endDate), str(startDate) ) )
        else:
            # Set end date based on observed data
            endDate = obs_all.index[-1].to_datetime()
        
        obs_all = obs_all[startDate:endDate]
        obs_streamflow = obs_all[OBS_HEADER_STREAMFLOW]

        # Determine observed runoff ratio
        obs_runoff_ratio = numpy.sum( obs_all[OBS_HEADER_STREAMFLOW] ) / \
                           numpy.sum( obs_all[OBS_HEADER_PRECIP] )

        # Aggregate observed data as needed
        if options.period == 'weekly':
            obsTs = obs_streamflow.resample('W-SUN', how='sum')
        elif options.period == 'monthly':
            obsTs = obs_streamflow.resample('M', how='sum')
        else:
            obsTs = obs_streamflow

        try:
            calibratorDB = \
                ModelRunnerDB2(RHESSysCalibrator.getDBPath(
                    basedir))
            
            # Make sure the session exists
            session = calibratorDB.getSession(options.session_id)
            if None == session:
                raise Exception("Session %d was not found in the calibration database %s" % (options.session_id, dbPath))
            if session.status != "complete":
                print "WARNING: session status is: %s.  Some model runs may not have completed." % (session.status,)
            else:
                self.logger.debug("Session status is: %s" % (session.status,))
                
            # Get runs in session
            runs = calibratorDB.getRunsInSession(session.id)
            self.numRuns = len(runs) 
            if self.numRuns == 0:
                raise Exception("No runs found for session %d" 
                                % (session.id,))

            # Create postprocess entry placeholder
            postprocID = None

            runsProcessed = False
            for run in runs:
                if "DONE" == run.status:
                    if postprocID is None:
                        # Create postprocess entry to store all run fitness data in ...
                        postprocID = calibratorDB.insertPostProcess(session.id,
                                                                    options.observed_file,
                                                                    options.period,
                                                                    obs_runoff_ratio=obs_runoff_ratio)
                        
                    runOutput = os.path.join(rhessysPath, run.output_path)
                    self.logger.debug(">>>\nOutput dir of run %d is %s" %
                                         (run.id, runOutput))
                    tmpOutfile = \
                        RHESSysCalibrator.getRunOutputFilePath(runOutput)
                    if not os.access(tmpOutfile, os.R_OK):
                        print "Output file %s for run %d not found or not readable, unable to calculate fitness statistics for this run" % (tmpOutfile, run.id)
                        continue
                    
                    mod = pd.read_csv(tmpOutfile, sep=' ', 
                                      parse_dates={'date':[0,1,2]}, 
                                      index_col=0)
                    mod = mod[startDate:endDate]
                    
                    if options.add_streamflow_and_gw:
                        tmpResults = mod['streamflow'] + mod['gw.Qout']                                  
                    else:
                        tmpResults = mod['streamflow']
                      
                    # Make sure observed and modeled data are of the same extent
                    # Don't use panda's alignment as this doesn't work correctly in some versions
                    if len(obs_all) != len(tmpResults):
                        sys.exit("Calibration timeseries has %d values, but modeled data has %d.\n" \
                                 % ( len(obs_all), len(tmpResults) ) +
                                 "You may have to specify an end date so that calibration and model time series align.")
                    if mod.index[0] != obs_all.index[0]:
                        msg = "Aligned model start date {mod_st} does not equal the observed start date {obs_st}"
                        sys.exit(msg.format(mod_st=mod.index[0],
                                            obs_st=obs_all.index[0]))
                    if mod.index[-1] != obs_all.index[-1]:
                        msg = "Aligned model end date {mod_ed} does not equal the observed end date {obs_ed}"
                        sys.exit(msg.format(mod_ed=mod.index[-1],
                                            obs_ed=obs_all.index[-1]))
                    
                    runoff_ratio = numpy.sum( mod['streamflow'] ) / \
                                   numpy.sum( mod['precip'])
                    
                    # Aggregate modeled data as needed
                    if options.period == 'weekly':
                        modelTs = tmpResults.resample('W-SUN', how='sum')
                    elif options.period == 'monthly':
                        modelTs = tmpResults.resample('M', how='sum')
                    else:
                        modelTs = tmpResults
                        
                    my_obs_data = obsTs
                    tmpResults = modelTs
                                       
                    # Calculate NSE
                    my_nse = \
                        RHESSysCalibratorPostprocess.calculateNSE(my_obs_data,
                                                                  tmpResults)
                    # Calculate NSE-log
                    # 1. Log-transform model data
                    (my_log_obs_data, log_tmpResults) = \
                        RHESSysCalibratorPostprocess.logTransform(my_obs_data,
                                                                  tmpResults)
                    # 2. NSE
                    my_nse_log = \
                        RHESSysCalibratorPostprocess.calculateNSE(my_log_obs_data, 
                                                                  log_tmpResults)

                    self.logger.debug("run %s, NSE: %s, NSE-log: %s\n>>>" %
                                      (run.id, my_nse, my_nse_log))
                    
                    # Store fitness parameters for this run
                    calibratorDB.insertRunFitnessResults(postprocID,
                                                         run.id,
                                                         nse=my_nse,
                                                         nse_log=my_nse_log,
                                                         runoff_ratio=runoff_ratio)
                    
                    # Store performance parameters for this run so we can plot later
                    self.recordPlotDataForRun(run, my_nse, my_nse_log)
                    
                    runsProcessed = True

            if runsProcessed:
                # Generate and save dotty plot
                dottyFilename = "dotty_plots_SESSION_%s_POSTPROCESS_%s_%s" % ( options.session_id, postprocID, options.period )
                self.saveDottyPlot(outdirPath, dottyFilename, format='PDF', 
                                   sizeX=options.figureX, sizeY=options.figureY, dpi=options.figureDPI)
                
                # Generate and save covariance plot
                if options.covplot:
                    covFilename = "cov_plots_SESSION_%s_POSTPROCESS_%s_%s" % ( options.session_id, postprocID, options.period )
                    self.saveCovariancePlot(outdirPath, covFilename, format='PDF', 
                                            sizeX=options.figureX, sizeY=options.figureY, dpi=options.figureDPI)
                
                print("\n\nFitness results saved to post-process session: {0}".format(postprocID))
        except:
            raise
        else:
            self.logger.debug("exiting normally")
            return 0
        finally:
            # Decrement reference count, this will (hopefully) allow __del__
            #  to be called on the once referenced object
            calibratorDB = None

class RHESSysCalibratorPostprocessExport(object):
    def main(self, args):
        # Set up command line options
        parser = argparse.ArgumentParser(description="Tool for exporting model run and associated fitness results for a post process session")
        parser.add_argument("-b", "--basedir", action="store", 
                            dest="basedir", required=True,
                            help="Base directory for the calibration session")
        parser.add_argument("-s", "--postprocess_session", action="store", type=int,
                            dest="postprocess_id", required=True,
                            help="Post-process session to use for behavioral runs.")
        parser.add_argument("-f", "--outfile", required=True,
                            help="Name of the file to write output to (contents will be overwritten).")
        
        options = parser.parse_args()
        
        outfile = os.path.abspath(options.outfile)
        if not os.access(os.path.dirname(outfile), os.W_OK):
            sys.exit("Unable to write to directory {0}".format(outfile))
        
        try:
            calibratorDB = \
                ModelRunnerDB2(RHESSysCalibrator.getDBPath(
                    options.basedir))
            of = open(outfile, 'w')
            calibratorDB.exportRunsAndFitnessInPostProcess(options.postprocess_id, of)
            of.close()
        except:
            raise
        finally:
            calibratorDB = None